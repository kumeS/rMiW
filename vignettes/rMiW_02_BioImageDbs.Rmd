---
title: "rMiW: 02. rMiW & BioImageDbs for a workflow for microscopy-based image analysis and deep learning"
author: 
- name: Satoshi Kume
  email: satoshi.kume.1984@gmail.com
date: "`r Sys.Date()`"
graphics: no
package: rMiW
output:
    BiocStyle::html_document:
        toc_float: false
vignette: >
    %\VignetteIndexEntry{rMiW}
    %\VignetteEncoding{UTF-8}
    %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r style, echo = FALSE, results = 'asis', message=FALSE}
BiocStyle::markdown()
```

**Last modified:** `r file.info("rMiW_02_BioImageDbs.Rmd")$mtime`<br />
**Compiled**: `r date()`

# Getting started

```{r echo=TRUE, eval=TRUE}
#Load packages
library(ExperimentHub)
library(BioImageDbs)
library(rMiW)
library(EBImage)

##Optional
##Removes all files in a cache file directory
#install.packages("R.cache")
#R.cache::clearCache("ExperimentHub")

##Optional
#extract R script
#knitr::purl("./rMiW/vignettes/rMiW_02_BioImageDbs.Rmd", output="./rMiW/vignettes/rMiW_02_BioImageDbs.R")
```

# Obtain 2D image dataset via BioImageDbs

About BioImageDbs package, 
please ckeck [Providing Bioimage Dataset for ExperimentHub](https://bioconductor.org/packages/release/data/experiment/vignettes/BioImageDbs/inst/doc/BioImageDbs.html) document for more information.

```{r echo=TRUE, eval=TRUE}
#Set the ExperimentHub function
eh <- ExperimentHub::ExperimentHub()

#All entities
query(eh, c("BioImageDbs"))

#Check LM_id0001
query(eh, c("BioImageDbs", "LM_id0001"))

#check 4d tensor of LM_id0001
(qr <- query(eh, c("BioImageDbs", "LM_id0001_DIC_C2DH_HeLa_4dTensor_Binary")))

#Download the dataset of LM_id0001 (LM_id0001_DIC_C2DH_HeLa_4dTensor_Binary.rds)
ImgData <- qr[[1]]
str(ImgData)

#Obtain Gif animation and view it
GifData <- qr[[2]]
magick::image_read(GifData)

```

#Create an U-NET-based model

```{r echo=TRUE, eval=TRUE}
#Width, Height, Channels
ImgShape <- dim(ImgData$Train$Train_Original)[-1]
ImgShape
#[1] 512 512   1

#Create U-NET model
model <- unet2D_v01(shape = ImgShape)

#Vidualize the model
plot_model(model=model)
```

# Set compile parameters for 

## compile

```{r echo=TRUE, eval=TRUE}
model <- model %>%
     compile(
      optimizer = optimizer_rmsprop(learning_rate = 0.01),
      loss = bce_dice_loss,
      metrics = dice_coef
     )

```

## Fit model

```{r echo=TRUE, eval=TRUE}
history <- model %>%
  fit(array(ImgData$Train$Train_Original[1:20,,,1], dim = c(20,512,512,1)), 
      array(ImgData$Train$Train_GroundTruth_Binary[1:20,,,1], dim = c(20,512,512,1)),
      batch_size = 2,
      epochs = 10,
      validation_split = 1,
      verbose = 1)

```

## View results

```{r echo=TRUE, eval=TRUE}
## Model evaluation
Score <- model %>% 
  evaluate(
    ImgData$Train$Train_Original, 
    ImgData$Train$Train_GroundTruth_Binary, 
    verbose = 1)

cat(paste0('Train loss:', round(Score[[1]], 4), '\nTrain accuracy:', round(Score[[2]], 4)))

#Predict
Y_hat <- predict(model, x = ImgData$Train$Train_Original, verbose=1)
# mmand::threshold
try(Y_hat5 <- purrr::map(purrr::array_branch(Y_hat, 1),
               .f = function(z) {mmand::threshold(z, 0.5, binarise = TRUE)}), silent=TRUE)
try(Y_hat <- list2tensor(Y_hat5), silent=TRUE)

str(Y_hat)

TAVE <- c()
XY <- list(X=ImgData$Train$Train_Original,
           Y=ImgData$Train$Train_GroundTruth_Binary)
for(n in 1:dim(Y_hat)[1]){
  #n <- 1
  intersection <- sum( matrix(XY$Y[n,,,]) * matrix(Y_hat[n,,,]))
  union <- sum( matrix(XY$Y[n,,,]) + matrix(Y_hat[n,,,]) ) - intersection
  result <- (intersection + 1) / ( union + 1)
  TAVE[n] <- result
}
TAVE
mean(TAVE)
sd(TAVE)


```



# Session information {.unnumbered}

```{r sessionInfo, echo=FALSE}
sessionInfo()
```
